<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Access Blocked</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
         body {
            background-image: url("https://marketplace.canva.com/EAFTQEWI-Ko/1/0/1600w/canva-black-sky-galaxy-stars-desktop-wallpaper-iWMZ0xN6KXs.jpg");
            background-repeat: no-repeat;
            background-size: cover;
            background-attachment: fixed;
		  }
	.staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #00FF00;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: template_color_primary;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #000000;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: template_color_primary;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: template_color_secondary;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Access Blocked</p>
                <p><p>Enter your password</p>

<p><a href="https://krunchykarrots.github.io/yYM-bk4i9fv-x8fuNhY0Nng5-LU-F-8G8g0ukOx-ONW4zVUhNL/">Hi</a></p>

<p>Click&nbsp;<a href="https://krunchykarrots.github.io/file/krunchykarrots.github.io/code/">here</a>&nbsp;if you don&#39;t have an assigned password</p>
</p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="Access"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = 
    ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassphrase(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())

    const templateError = 'template_error',
        isRememberEnabled = false,
        staticryptConfig = {"encryptedMsg":"51e178196bf74c22a39211337facbe9be5a3b2301acb1b53ac0eb01402acd14e4c73e57aabe95438f4368a0c10c4a834427bb2817f2026642d256ba1d08a6bba2558e9dabe0f3c04c6fb7a3953e9b7d288e0581446612127474384cf3ab8ca9b9a7121db7b073e17a3b3077fec752e48184386c46e6b4ba4d4cf49f2739595c88676b12c5c8404f51aff3dc292d347470cb7a9cf721dda96a64652bf7e930f65236ad277d28beb6d8bd3ee9303ea4ce8707e7e532b869453cbec011d1a0d5cf21588ad133dc9736febf700e93635c027fee7a5901bdf21bf1d1408a70ec6005c71bf738b7456cfc3f9d466905f76cd528fb130f3d44afa1b6c006e4575881bf002494ac289fe787550b91e1a219bf127252e6c12ba45d22a54f89e479e2c5cea155d05a0a63a8130541ca90ab69f047a786889073f50c98823371474efedf4876caeba2596431f69bda8d2d6073df7d00ea29e9496ddd6e2cfa92cab714225c111e7d17a1c651cde96300074b913884bc9d0d331c8d01df66b465b2764410a8f4bf1005134ef1153513819d848376f98894e1af153be0edb0750ecbc7d1172f385a3e263ba34a0eca92818db6cecb9c7b2bcc4adfe0ef81b875cac572592ec40abc29c8e03268f7fc96581ff70006ccaac5f7285ab8694998cd90dde26f636b8ea6a3a6cb1e16d07f332975cf57de260b57db1dc2dd42972f12e2a9e762e4b049b34508d4ff2ce369650c7367925d85937cb2b6e0a3bec601a2e5405dfedf348f4d6edffa75124a92f5be5b11bfb6b73a34c3af912ba67d74130cfeecf92cbdca490f072e589de1dfe5d60b088396652d8273bae064a5f567efda182ff229ae1e898f721e6d489cff359298ca5ad97e4e1c4ec14c571a6fb76e492d0165926035179d21e2cf3142600c4c5d4b4327f6a4c6f25f7e15ec684c2f1d572b7f177a28fa0d5f23ff07aa4ff492946e02bbbd397f5ad54d1121880e765f032a6c3e0d0cb50019aefd364350d4889f18fad024cc060226fe4dde339efa70f1bfdcf487774a1f3fd1022b25b25e37765fa1637cb33e42d70599257817f121ce01f0d30ec9cfef99e6df3b7d9ac9e7a31c7c6f39a1b82c1cf9031b177ceb47d1821858f69745d66ad28987424dd70f2bfe077220d344a9425b495254293aeaea3e61de52924177a5690d406c392d9071b91ac72ffe59711f48cfc13571485d4de2fe888daa559b56c0452e82cc80156786c21c2ad43f746cfdfa9f63e84b0ef0994ea5945535111531c8e9792e7a64cb9a136e2049b97758fde813bdde1065e7a500ad5420a2cec4ae1511f6adadae7219c49b79aaf57db6c98875520c5d15426c3764b0e7d07b6850694cc020e3c573f7f81ebfe077bfcd90e1e25b2ecbdbc5c2843437bcde4accfcd5519364f654b2a2d5380d8b32045e14f8eac884e230934d185e17dfecb8b3e7cfbef9911becda3505f7bade7a36d70aefd43835761ef6d185e1393f1b0130264b1ae1db042db84bee33ffcddbe5085484c067f2f3bc827e8f53000b7c174ee49427709b310a79e2440f7f3846f60af3ea6278d287fb9435c07b62c53fb3bf40c258011c6661df850ead908368f7e3468f75b145c0767f2b3273a38e69ae5d43ad8ff7af6227f3ab414a7ddf2b65c01b7b4b82e345a2e2539c9412988025569686fdd484de515d0510dc9f6e0873e6dfed646b44fb3b9f7a6a1a3cde3cefe909ead32d40a93411fc7c4dfee386920c7e82ca4b2f048b6a7621822a131593947bd62934c5b3e695c612e3f371749bbdd187a84e4ce4539f2aabae167254cbb0c5138e8b5a38dfc9bec0262c34f2e4fe0ce3224ba2c6791611092b283fac310e8d3bb5d30f1f21506f12d0570bad165767dcb288a2da335d529ebad493be106dd445b93db5d9fe1729b884c6c69632f09a22a1d0fad7e1fd965d77167cf40f002e7f5439f063478a52810789558160e1ac2436a1caccd646d98d55387cf65175f0ce4b189b5f1c7ad65990084ab89d708cb00a007db48649b02b590b48927f0604aa458fb4080807bbfb932b5a2d2353e5ebbc4776217df32b531cc3ca25ed75388c9c2e196cd3e435d634a008b54297429f13e1523c2a95f460f6843a2be6176c45285a662525824248d0b55e01ac054d4bbc76d6e16c965816b0a6496d5ea0a243f667e3e088789c53bb065250f26a54f513ab31044cde28ca6df82cb8598effc4f487585d81b32bbf831c34153116010d548e0c46c7ddea2fb61fd95b058cd610feb3a6ecd048dcc7c61a23e5071833292d1ce5374ab06ce2e7544dfa59e1ee3eae90ec50780ec4ec78dd8d8e2a0169591089605453b51e1096b210e95699936305101c83f3fb93c07c438fdf3ec57c36fc1cd3d3a04f9578854ed6d3a7d1b0c66f83e7237c13f09eefc5a8d6f4f4a2438130eb74bf0e82a928a396591988519b997431da28637fdad39d251d8eb18f52bc96a478f4caf355b08ff0b782210cdfa5e8c6937a774311a680ab4b67f5cbf422bbdaf312f32b6f44c9bbd3713b9aecef3cb9506684a93540d80d3b68a15b1478cfc798a5abd4871f11d1dd9eef6d048f4da79a137dfd2077c9833b190f3cd6cf5032ef08ef93db69f723a6472a41e11be93bb44b15219f612b78262b71441a07c4677f24a1c4fa44024c7d02a76d99425470301cd66ed4061dc8fe8cdd2e4a01ac4e2b974b9e7282fc631de258bacacec5c6edda0306600091ef2c4b0bcfb9f3fbf5c0c952c88b79ba16d5724e24e5fde7ae01fffe466930595cc0f4c793fcf235be0cdfd878ba9e3fadc0fd530d8240731baa440be96bbb3ea631303c96a5f8ac3392f4f2c7ef0bcb83664f0b37188117f13df4e84e8b0d61c62f723625bc31c31284021c31f64d591fd1cac30ef101216f1fba4ace3eff536f6394448bf71c09662a3d40951ee1da7549b4b0f572671de8664115c372932ed8a6a034d63270991f7b64341467220bd1b055eb042751909284c6eb1af5c4fa0d129253d01cc16cf60278f58b7be370433cb4cbd85f5355df645cdb66aed9cc3f91a49a6bbc0743950d74fc10b48763ae56c2c574d8b1539954f1569cb1f7ea797eb117845fae53d3092686dd7ec63e1ef9831794df08262f2b9149a37cc635d8b15b78caf39fa45f797308300dd9ffd9bbbd4d758fe392b120e6b1f032d4792c34652565ebab1b7ecf2e74199e69e4b7e9ee5c9d72441f3bdcddbc91386594e1ff92b950cd906bb3abdb7c9c907cb94172adb3fd61e62d925a604bfd604da16acc8e15cb0ae823073c8c2a6ca8c40910a61f1462088545b0f5de8ce94b43ac54d5e70f92ffe3686b490f9401d37705e5923c2d9034ee31cbc1444790ba51837d4702aa701302c33f14b92a74671810efa4e13066f29b152dacb085fa9581f80f7ff74096389d2dfebfac5a47a1ac9b0806a78d269d9653800186d329ac13f07b264865748e102d9de812a3ff76a0334a6bc092046c83d9ccfbc1071614e119326a8191dd7952016d0de95cc4ad03e600296548b27684b896be1ea442a89b3c1dc8a39f55e7b21fc6b14c040e0a0e2ee90d3fe7df40eb2548f99526e4545f2feb50c3c9501caa5b6b77711eadb03de27c4dbf5cfa3d231c1843effca7ed870e24e30a8b8e6df5b399d6fc5aa42636e5f40ca9285023f69e8b4cd117da2400ee0ed2c3b4f90d17eb712484f93b7dec5bfadc3a87d208e5ed7ab8be2fab4d821ed73a3bb9107981dc48973f74f988d22ffa45ea8cb5d3bcaeff4e3fddbda12e38cd2e542c4e5670a12c57075db847bf5290fac34f3ccb23ee97270f6116bf7bbfe7ff212d84f11939a1a83e63950c2137baad9b4e1ff6c8771110d278800d5068a3dd92893e8c9159e29d80d1fb85346f7d2be88a8f5f28d086fad130f3d9aa6db3c2b428af7e7523e818cbca73eb44028d083adf5046c2d9d40cd2e8023c8e48e2e82c3465e1492e81133a8bbc5c71879c557ac0ae0efd2852a0e1576b3ce68fea153519433a3b35eff6314f8f295d99af9f0cd829b53ca4cfae5b47e0f0a241b7096cca58f2a08d82b15dc0bfc5b919aff3e3ccf1b309c5db54336dbfd782ce8ce767c0c174edcf2add926747fa1883867b7ae5c38fe368eaedd28077e16efb7352eda12d08e6ea7fabf985d8c3eae0e1312dad406fdde3a9861fb09f85c32b8bc20ba6d95e920f037877818446cbf11e4dc2335de208f33ffecc010e1e061fc74385498945e87978390df85f73cab556bf2cd03865a6e8ed7072dcfbe0a79ea81344d9cfe7d5ed66dac5ec2ec9a2742a475c035218bfb04b4319367b4e1ffaa6491e63dc01ed3dda9d628785ea602873a8e7d0e7f8a4dd668232350d659a44d5cb60cefd882c762e150c6c67a9a25bf3042a4046f2d6ff6e5c5792cf5fb27ead787d2fb23b068a605573aa11cb9b8025d4d389d2558e977baf8e9b6b9c1cbaed974d72521661479edbd02e1b3a0973560a51b15ecbec1705e767f91e9088b11ec90be523e9c765c7eb4b555c577bc2098689e79c8473b9129d0a8d18ff6b7a042c656997e7db552c78919e8ca0ce37f89a47d676455fe847e733cec0f062bf4f149b209891db9a09b0ef2288c4bd74bddadde844ab17723adefa0c40f5deed69c823dbe219f23b0dbe197f855b1eccc06c99122d9c13c1ad28085a9e750cc9b46b68cc009c51469e3be6266416bad4f126991b070e5c51ea604d584e107a73c34cb52fd61468b859913d3675195f5d8fe31faebf855c7663e9634a254d9e6d4094a29dfb52916ad08c586562a9b9152929224b59b38a6738ed86807a26ef668da06037b0a846b1f14a6d55520623fe3c627c5fe95ba8679ca7586ab244c91fcb86dce15b97564a4e144c73fee89ee95ce23163c9e7f983c9506910b3d49905181cbb55bdf8d91a45aa7e46515214ca5499cd7fa0658ae4ea470751717d7f8213772376a59905ed204deef782f2d7ced0a0de84a6feb6b0001f7f8d541305acc5374cb5825bc165d904d763eb65a412ca1d07b541b6f9ac239aee4661d85c0bcf16fbf1e22580d27a9cff74fad6a88762143929e279f8253533165c2a5b000e7598129fd6192a08d2cfaff0ef19cc8dfb11a528624e98e8b4a8477875da9407f76672429bf8214a25791c53d6fb7a0fab298ce840021033ace646e1e6a999f925e0fab294ede6cc68216c4eefd5ff225e607eacf6d07c1fd2306e4ce0fb851ed06b22133fca1182c2fe1d3ea3d03ca3e8aa1f0c360db59863a514cd29983e66e3d4b55bc1d4025cc25ea44ea97f529e3f8d2fa905836c0ecaeae958c2a2a2c9e1655486745a3314f9d3c1c9fd69ab580f94c3a242d03bfeac7eb6a83822f83810df13b7b5bd9d5adf9c1da92424b48e7254abc3d570036aca6095243bc4ccc60810c501c49af66ab5379fcd4ba83a1173c70c212688431d4f435780b174325a027b2d25a187370a0a49b9ff8a1f96b8b79c378d903f6427e66a42a7f121dd08ddf751ce1fd35d5a9ec17b6b02b90c47af5f679c9f8db281a4169268610abb8feec2ebd78d11383e119aafe025a803d83c958ab263d0c6805f23d6f4b2f324352ef5a8cec6cc34651c187ac248fa9fbcfd273c65e7c049b4962b99e50fa0b962ef1dbc4c618d1a2fa43a9ae7ff8f44630bcbc34860ad9b6692ab3136503f28004e52b21ad7e7d02c3b9a5eda60287eb45f24714fd50830be371b265addcb97a06afa1c4cd4ed4b5b0bf7be482f805de0328b03ed1f17d48b02ee87ff79d0fdd130863f55c70995a4002fbb45ce93ae1c42eef9b13c6593e8352da64e7d5d2820b6be0488e3253c179385425d6f56d11af71e25574f48cb9afe8d2c3a35c71fc4dc96a47d4d1de747730fd0168c1a260e52ac85db8ab3bbeea44c08c6209be0715f05e1b3ba0e49b64bb860c81ccbe1486e17a69c2e48172518afbe9f4deafe96aabd5426f8b0e6b46e3f7b4694472a8014385937ff79b0e948af93b9f5b1825b377f43bf3ada67d7f03a83d33d13f066a98e4f02f06f32b56c8166a1f5c11420f0f5568fb7939f87d080088820a2f630d5d037150e099d926f075e4ad697761ac6a42deb4113cf28dcaefcc32a824b3b72831e440dc4ae5059a7711d5692408ac61f29b03803e209d0390a78d3c1346866ea4f83d6c361ad9ae2d0ddf92702081a7ba1a92f98e0dfa49f212f292ae0bb684f07855856165f4c808b700c3f729b4ea4a9e3b0c4ca4df795111f2325cc3c2525a5c168372244174f6674ec18f10bb4e7c6c6e19c3151d3246d555eaefbbd756904ffee9d5d9fff253c176cb193e257c63424ca560bb5d7ef94217393a2dc5261eeef92e320ee7589d3c0c8a087e8202fde20929be2d2a9fd9c487e092161942a9a2908c48ca2336efebfd023659b7590a6e6d6e1a66ace7b71ee0095cb98b88fe0bd02105e9f461c0721657b0ad3d9b3eb5c85ec8626145bd976ed6bcaa282db2d2b65fa5a4848169838e3e9c545d27c81bcc684bba788f6c3005785011751f96de3ee1aa985a7a6ea78cdc11ccf9759aa16211432fd95e47b71c1cabbd9fe95946b9236ea5019a2f4b41d7e789bbee8ce5e34193a317eb550932a9440efb8df1be145fdb14785b313f8436745ecd686ccf840c61e4c93d150fe788cf71b90fe6256a7e75d4e7f68c55c093de4cfacbed6f7f5f6c1d5e157ef4d3c071e02c39c55a8354ff679d8d46794006cb4efe760ad8961a00f94f0030a542e50aaf642f28ce469249b7f76d750809a77406cf5c0d95106de4249d24a64e7ce47e0e40be1ffe390494b16ebdcd9670df18eb4327f95580f54d5cb69c5fe269e4f6f58a239023c6871440512600aa436cfaa069a937e66b46dfd8fcd1ebaac57e3ff3a3dff7a672f09cbf5437d61a16471675a18c9414629eb280feac795c4ce174d6b42878ea646474ead0d91b137f50a422130b8c24438006eaee9adb295a0ae95cdcfedd25d0c8d1165489d9341efb94547c7a6dd1a0b685a738413172b15c4b76461c42b53088b832b435059f795a791fb6a5c95e3d002fa7ed74f30e89db7465f7c2c5199d4454d4ea2239b644db8180b9a4c1d393974bc75fd9d725a920e0f32fcaabab908cc556f83709d3b098c5df5dca011a555e5d1f8a9e5db1d29433cfc4fe63b7e827660df2399839c86f2ebfd13574677be38d9208c7f8aa8b1c47b8690709eef0d2adce8038131b9d79ba1d1b75eb0073390d551a9cb2a4ac1bf62f91d2fd5f0c09e0f8f245528332af9ccd3ba589c766e8f6012ff4bfc027480836eaccf5af178192258a0d55964881cb487798aa54b6c8afed4dbfd7bd71595067e93579af822682b6de7b4892e01769f6a9fb950acdf5998bfd4455f71bfcfc7b0007044a2dd1ea0b3f3bdfb6dbd2823b514b5d05ba34cecbf882beb833385ce51afc197090a5375fa11fddf8b1859aeda32bc1b5c1178cdbe73a5e2e36554ddc0f07c12984df1d2a3b70d4c01623e628450a9e22a415e01c6ac2073ad46cd328da0636d970abd1d5a0c7c309333bca07c60821829654d20736c53eb298e92a59c7ff401c8a5103b6778836cb5f6c7c49bdb1615cc3ae71ac3f60bc97da54ac08d4855c3414a93f161a7a0ed7b4494dff621c65495f9d523ad09b9553207b539900b5832901c24fe13d8aabfb6a8140cd38450a6c9b2a3804631d9f37e8ef0985d41f68c75fd7834fb9a53517d9c6c5db4982ef674edda9a32514ddf4729f54afcaa4f38d647fa3fd7b6ea333be4c20888f201b7c38f40a4df081cb5d23ed060ae6f3d4bead0a547e6d503c0170a5cccabf888854c2a2cc0dabedf9df301279ce1fcad989e3f42fd2ce6bc69a406d005b6f39856cc9f34d2ddf3611650ba21d6a7df9a9cc8d3c1be308b8559ad6021b9b8ec46e921da2597e0fc9d3f996cc7b2722966a93edc306d00f5196980e050c64d77e98e134d614edeb523d80258695866334f4ae657a9d5b5fdb8bcb24226390e79739e9efff636eeea9a70471f30e29548e2ce97757ec7bd93d12989331a4d95a4983c0d9a04f17336e9d52d2cb4dcf948cb3c49d73afd5a81dfe7dac511b6ef68955291bb69f5df0de3b36cea31b605f975a3c3b730360dba039b52e159140c599cbe07b5ee44a5905e3a74d0ad6beb3b96d94b3132b2872bf343ff8141b02f834e1ebafd7923ef60d43b065a1717b4cf6a4d4e8f9c59fe439c43a7ac1087a635c6390785c476596908fb4181cfbe0fe5a4edb90663ba64546fdd9ee0fac301ac591dc42ddb31ec7d0f272bf3f7ba90937353c08e18138fe608427292da3ac2ada3e9aead47f996909773129c826b270c2591d0e8445f12264dd9cba831e0c7e5ae8cc3e3b7894b702d98cf5918d13cb167ab73bb746899876818dda87ba43f86290144a672beb4e405894b1d0ebbc9ec58ada50069fc46e3df90f277d21dd0d92db9d73953eb72bb97424c6a8dc208de2c0a83e76f063c7bf97badf85d0c083886dd2b32033f25d31184e337caabe1088a4fd3fbc14f29277789d22404d2a17019df251955a62e804d976d8dce0cc6dadbfa7e60068748e141ecb8f9ebaa6279960bdfda4d42d67cc6ec9c0c4ac1efd40877dca77c525d25155736bc6a303f5cb3002624cef337e0602c66866f5de8272b8eb28410dcb677a185893794c4d1cf6332779e84a19373629e3000eb4f8357237235f961a023775f45e05beb495b28fc6a02eb089f94a22f957f9a2cadde0d547072c6b5b40db5748918b04449efda6ec07a39d277093d23f63e5a0bf88e304a8cc6f340f08a05a074dec96adfc427c0aa4d2271925acd8d47b3628d971439dd9f2df60c5e5ab442180968ed90a1125c3ddb820814d9f96a9ba250b1e959b662c2255eb4b827939cd50bc6e3b7f4a07e55f0aa95ff81f1718c4e01e6a7572cbfa81a6e6811c2f0c71609826bcbd127a81a44bdad26d861b55ce89e6ac827bf90379fe6fe91e2d6e3a094b25b953b416f78716dbd36a31b1a55aa53fa208b4f1c897608a3214e63032f993fb81fa11e66c63b9c4716e4dff32420105ba4bb9ac8be6854923067d5572a2f4217b502ed9463c188738d2d64608896654b9524d8a573ef759985bc53bc5d9cda0271a43694b398a5686244b298bdd0e1a48dda165b41088c4e1484847acd7f10f38edcf35e795e319d49d3e511c6120d513be160e4e3ff551d2ddbf3cd94242ed8c7c97843fa5d4a75412582749b5cd1b0aac16e63e2daaedfd93bd599501684eeed9475ec16fb6aa86352bbf2e70c308bda04f31f7724107a99569cee5769034b6ebbad17e5ffd69afde1c0114413be9ae082b4835bbb4175c6ae8668cb40a2ef5e3400275ceb1ffe980d9a2b535708442b90329ccc3726d0bd670b079504b8967bfa6e9f0aefb14c90c698e637e0cb485fe1b296e2765c05ede458ab2520dab090c126a02b095c72d94c51f6435b2dafff36bc5e7e0bec4462d6e2a769080e0b4a0582badb303e2ed24d8add2f1f0368ed934ca129a9b38243d841b96a2cfe83853dd7dbba704dd74bbe9b519fd81b64f8ba0f63fc8dbb07a131433c68a2558f1c3b39eee055aabdac2f327464ca95e34eed62cb286af9305f3b7964ffbb322adfe064720a25d75da517b686990936b6e8d2339bed857b57312a358d4a94afac11cb3c4bb85b02bdeae12fafa0b3b6a04f83115b456a5b2376a6cb5ece1b5911064c3b05c305a7c5aeb75fe585481d21819b19bfad05a68d953da931cf7cd7b521f02d07e36e151608eff3585e871356888a3db2a952ed07fa05c39dc478a7d95a602ec12b9cd07bc083d0565322cf27d6da16da7d05a232290d95b2d5406eca9d9630e0046450794d61ae94a132d0dba0047ef7bb89107865fe10eab99ef340d5524da37c8c79c9ecb78335f1f748e5d2de72451f9d4870e58269bfd7b5cbc9457b2792ff0c0c3395a55efae8775da769b2ebcccd229bd40412188e51c1656345ed284e728e9f7573d73608169c445515e75","isRememberEnabled":false,"rememberDurationInDays":0,"salt":"62e675dd4059bc6b5ca1bed83a3a7f2b"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(passphrase, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
