<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Access Blocked</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #00FF00;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: template_color_primary;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #000000;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: template_color_primary;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: template_color_secondary;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Access Blocked</p>
                <p><p>Enter in your password</p>

<p><a href="https://krunchykarrots.github.io/yYM-bk4i9fv-x8fuNhY0Nng5-LU-F-8G8g0ukOx-ONW4zVUhNL/">Hi</a></p>
</p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password please"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="Access"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = 
    ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassphrase(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())

    const templateError = 'template_error',
        isRememberEnabled = false,
        staticryptConfig = {"encryptedMsg":"25473088c09c2206d18cb14d4f495a9fe45a0b07d1c1ebdcedaee36f49d418c2e1ae0348c027c7d465857a9ed414456ff2d2857a4df1267b531aafb0690652b3c315c8e80de6dcef90d782a3806c150271070af65de19ecc9293b4eb0b532c6896552e7b553a08a4eddb6787a8479f9b5e4f3ee89b6fe7b17f9a233b026747de6142ebb588749b1f89a5f331d5ccd8f194442c882e937ec0dc58fc6bbc674de3559a2000024b2b9ef9c86ca3254f361828fa48adc89539efda766f8be257ce7771b56825b8f5d82d0d75d9f2238a8657836c6d27439ebb9512763fe406f0fc9ae72e1ca79d2dc2eeff003378fdf704ab053b1ccf3367670ee6b4c0cbbc92943640e58286af7a4864408d87332ec9eb08ca3cb5b9b41e896035602aa602a4c83248c1c95a557d08f758bcab763a9b7f1ae7c3d178712675f6504b50d94f00173235b8238edc127d645f6e50600b97343ee0d10bae5308ba271de281d569a90ee90db961c7162e61242f97f4d6119644ccfc6152b4c044a19bfcb0ec0ca61e138195f97995fe1375ab9a1c22ddc8db83a265a7e4ece7ac3a0bc1fe340031db35a24dda3a67cd26e737ac2ad3a3bd445e7ae236a7bbc5764038f6a586eef9749289fe3b8cc1f10496e2ad50890bb079d46c56c09805d698e8534e54fcbb2fc9ecb1e483c49656716ad66261e0b681191235bac4e212a0912fecc4d82c5e3988da10062ad506763468ca15c6b6877b1824eb82aa9eaba3f3d3c2bc2d4821d8854717d88ef4967f9b7faecdf6835fdb35dd8947b6cbdfb55fd07c51dff41e5fdca011325f4c6afd8898c41934b44ba5f90675b2a6ba783242e045159ed7891562a71305d644c8c0d4ca631aa6cecb57a2999d8d4efcca6b190b006067fceab2c5fec34d30a675762171308a458658fc0be79d01e5e8eb306ddca0fa57cb43a47695bb0eccbbb567b096dabee72d4109aee6755c4ead2b2c88a0f5c26d3fe1680727e3d41856f432fce84d524a3bb1943ade61362f217c5082ba7e0488838c56981c7db6a527cefb8393523ef0de340dc35dce49c69777958296a4703d78385cbea7ceee9003da46bf85057e59e70cb3fb526656a96c989357a5826ac32fb798cb8f30128a27129c8fcbc74953264d76c200061c1bc8fa48570537cf2046ef27914001ff89854798a9cf3e824337894fcb7c9247cef05ffbcff0e8ea3382fdeb24503a681ed2e6afe491d945bb7ed0a047afd9a94e055a914f36f7c56695eca6fe5dcaf600b1855528e96f6f4f5b0e9805a6af2d20da25c1218094f69cb7eab8df8fc2a4831f2a85a727aedd488d382f72fbdeb5dbd5c90f04f9408fb6de42c0fba5c62664031774c54bea3d6f9917790f96f986d2ec256d959d86210bc87fbe2dd3c7eba337abdf78015aaebd8e62ec67b756183ea739a125d35d6f9b18274ef2bc00a6d8b607fa801531dfcbc61bad64f10392523d0b9526050800d91496927a4ad10c86081d5a2330c14f3528c70d5b8d801972769fd69f6c93d31924f8306e385e64b294ad57542a4295fc501b2243ffb41ec6a82c3ccba36308f054959ce2d9cbefcbb68c771bc23c806d3c02459f13b8fdd9a1411814525d509c9d87f7d0b30753b4ac6816b7a85e0c4cd65ac10fdadfc261cb8cc3bb45e66bd4596703d88b40fe56373b9d7470844cf3ece04511deaf0234207ace8243af8b3a19b2db7adc512e43cc0c5aea08a610699e3204942f3c01bf4bb0b15e6106c9936cbf7541cb9f668258ac1bc36f3624d99f927acee60687003fb6cbd49db5070a4b96c4a7bedd0056deb04e24efd658f8e92271b4d17e8564ed53185382e8a7f0ec813601323e3c107b59cb9f10825865fa481eac6c139bbba6a8f52eaf97718d982002f2705cdca97b7f0a9060e00d23a136762b486300706e6a5a133dccfff91b6603d9fb7ed45c7a166f4514ad33a02cc37f3aae21c9425b5510f9c22a098b8967bc5ade307af8153052e1d2176300c0818a80121f03d30b479ca74232c5fd88a62e9af1eb1f6b5730ffdef5b1b3b04474305ffd7bce13f1939d49f1b67ff4d63ab81671995c0294418d692a2eed36556651a64ea74cd94d470eefd4fc15227898a7f4c45982c0b6d7a5c054b1b8fb7d306fe169ff6e778403fdf6bc2ac8f5ac5903a6beab352139af8fa626933e41f1e6c939ee776ca4c6437d03173b1b9cf4612290ed262daeab34c35221b3c1df0364b079cf4885e6857067ab0c985e6b0803016ad5abea0901b2055135fcbd6a4effc40a81515325ee651893e42c80b4997d3028a474cbfefb294dc7091e9581d5a776491161b5cbbefb005241d9f234123e48805eb2102f38ec176718fcb8de744362a81d530e5b51040a8721e7e4b53874d34639f8a330b6e079e323e5afd497a9509ef646699971bf701de70bafcd896a411fdbd696371ac36a7cec32cd41015b9d6df3c1a93f62e4923bba482ad5c7a39474e8ebc76d9e83a644f0afebd9c7687d966783c8b26801249a834f49a36c197de761600f80a495cecc316e3065796f8dc35111e0cbe8ef850c30df1ac40606b18c2bb95dad036ede16b8956be1f29cab52f52947c5ccc9d92c140a044ea0611517d2d7adcc7503e586f0420694e18037ed7217e45c1b17fb145e05f17bc80e863a6d98396cef126b30ef45b94351d6efff5f45de70c18ec9eb346fef5448a5708717ba06f6dd73b4a98ded3e49b2233a03b2f67373c8fe825c46f2393f65d4b9f0ef870fb84d7b7e5851aac58e29283199396166ea5755d118e9144278a8a861e83046dc91fb3bee09ef0701248039d365f2dd7cc10c497ef36f3f74f517352041abf5cb0d956ba3baa19ce5dfbf94771048d842cf639942458c7ec5a29b8741a70ef51cfd1a25c19fa5b4243152e93e11cb4130ccbef250eba68600aa8f8ee35894467a3eb00a8fb2358e7fcc54934b787fcf0d70282ae4e5bd2f46254f4a2c3bfbc1ecf388fb66281661de09ec98c619ef7e625528db01d1cf7e383ead0adb840a34f7f33f54557758f4c1ba331f24cab5672879ae01803d7ff20d629619b165347c4c3dd0407d6a37633c18352d317fb7c009146cc73bc32c427914cac90993e843f9c31d6c722d5ba685cf632c96b51318870b3c764bce2e0236c6cb50d555da3298a4168496716601fe569db6e6c03abcf298afcc4de223d0f456137250ed8eee521b38df44578f118c2dfcdb759dbd0dd86d1d7241fc3930ed9b998ebf099dd64fa5e1b78a8cf634f1a548205a54fe0293c88e12d33a7062db1cc60a577c0b1968bdc2e7c194cf104fa283dfad3ce05201722a4dc2cb0c8049e8106be3f3475b49fb24a1e8060138b126b5226dd19971e4e6283546886cee8c841cc06365bd2d4e2a7e37611c0b80ca3e997ee3d213d84d3442fae06aff578e368b75b923ed87e5a71e8cfec756148f381c4c5fd587a4f7ba309a9a82bc10afaad65fa95c0d24f800f9d99511173eede477d912c790e09d348e8d130c420b09150dc04628c77b4d8aadbcbc0d335a5d073b88f2ccfc1e3219d6f27466a2e8c512ca5da3cc02f01503ea8e42d8239d0002b5da2860c274309dbbccf084a3f4ae4624ba2c7a7cf3f614b9efa89c253c254f4d6f5a850bfd9f9c69fd30eaa0b2b7449edb3657d1926fbd3d2962cb58d1366e55f8b62eb699d4ee2b96b52a43988254a7b99e2521d083a47b3f27b262f11dac0d4d57131603567e160efd651f013ed38dacaca882c50c9dccd88ab7404a7e7b2b0c9d5bcd3d6b70a64c9c813d2786e01e2cf475a64938d3e240a049456d5710692aecebf6ccc7819c607df166cb95b9b8926c8b9fb3fe36f5212823921087a9b83f07468be641e39d6f70ec21c5303fd8776a91fee6fb60b137254a11acaabf54c932baf604ef68963b67c29e377ba9b2cf343d06d6a54e54a7225bea1cc8f7ff5ee34fb32f03cc41cc0c7c415ee0059067de4cb03f12c0d82b772730051863fc14cb4a8d2f77e0abc6f5ecead2b1cbcead645bac83bf0b40e39bcdf0374b35d27559cbaf525772f6d30f09c1582a2526cee0aba4534bce80522941d51370fa7e559ac0f20d24efee0a82f9900fefda7e28da6cddfd25eb147149f696eb879892c0a6f4e1b3d279a46f99a40f6d6c8ebb9705850b220664667376c1f072b0f9b3805fde89c9fe5228d5dd052bc7badac5ca762558fe5d9cc738a0f0d4badec6ad2c8c4fb64af43117454028d33dbd764ba32c4731f7860b425c26718a2f8d687470227da0a74900c1106c995dc94cf6e785e227a9a5d44c05b7eacfafb29fb4ad86db4c6739a3b358324a5e1488e86283c173af6242ffec4045f979176e722c54fd045335188aa7afbe3a439842b3fcfa0b84f5783ecbf618f04d04ef913b616868ea5e1d083f4f68ad3dd926383a4bc07167a2a65d8e4eff3105d8d77ad76e521309115e0ae4e1c9cc60c7b8b070f7e5dbc81e4d91f6e9a1d0a3796131aa9b9fab3d312f67cb6760664192a79474fd5789404f7031c0d47272a5a39a3a9a7e1e1fc8e14b2935b1edd29259dd6e32ad78272d110c28698f17cef0f64c07179af509d4cde0baa48c378d8d08b7f63d61b66967ce3d5db611452487d4b6dfe454df3b27f50ea1ff49fe0c61eebf1a987b5ac1cc58931f4e944c9fb99f66147ed123f988226b86d08d9df7eb6d9289ead5b421419985383bdeee97b96fe6dd7f5ab41a176fcaf6b7b727efc46c7fd80c1e43e431d4ac9c492aa2e40aedab7cb4b2dbcd4df98a3d5c9d052b193c9716c0bbb993a7878f71a26a6f69ad7aaaad58de2ea3c41ccc33f58ba1108c3e406a63b65aa3bdfb158e42d67fd3ffa55016cba296c058a7215a2625243769756c8a8241dda894f70f5db17e1a2d68f27d47f78e2e8ca4eba7afb57269a28930419b1dbe54287517141b83104cc15fe066d415073a132799bb11bd95ebca72c551e967c949e486693f343e8abfa8e8b3a1987b7e61c98a177a99e3ffbdaece45fa0d195f6a8c4b6c4c887991eff682bacc827efa0d7c5bff078b602807572d5c3f573471d105106b33a3649b9d7b38cc32419c908d71e12dbe8a3b1df0beace3d372753836e3650bd025e64b25614362796d8dd6c2e846745717d24bcb97c66b107b0813daa228df668acfc3cdda3290490595bcc0d9e660315585ad4b3ecba8c7fa73c3d810795807b8c70f0ec8b7fae915448147b0862e70164c95b294e158f128c98452200cad3d7b48908098b7967b5803639e076aa9126b129abda751445abd404a2e0937b3d9edadef4416ef37e8566f7a08aba411488a78bc0c59a2f183313d2dc1475587cff49a6b3f6db0058257cfccb3cc7bb0c19f0497cfa5772b20b2b8d9dc2f54244ad3bae3334d395751407cb0fc434e2929b6e123313f75b1b0b555b5726e611d05846e6ebbc2c249471d8dac82674410b14bbfb33116d880174f180f63a99a631db627dd66b1137321f50123676c74bdd70a49ee0eee52698902c187dc26a8c93698862bf4facbad60ad8f4d357ebe8e4723e2c1c51b53622f61d9ed2edcc7b4a16981dec8bb78311fa6a13925cb065f9e5112c137b872bf95baae6ac2b284594a4c24f87b8ba3c8702e335edaec46032b73455690d0402647cf4d0c961af2b094807ababae6be2feb338e822f672921f1f39e474b5dd0ea9c33deab08efab128014e184e72572f0a127957367e0ec7c918f786cdab113c8b84aedfe720bfeae324b3e000293d2d16d920430d9639b6204ba8a3f127399ec44979f3068b165ff992a95b8009e9a48511c271137a869a4027b14fd428ec4750bbab91bb8d4593c26e6c53ed5a8af95db2b2a2c8dd144d81292785d43a3c403243a09aef5f492332ceb2004a95ca1e6321894595f9baa98ac1c58880940f9e72a3218be41a8834a87c9b74b2e14d41354677c30d688349fd45271ac51b287082f9a3a0acda4d38f49e2455b257380268f131eaef6150e6820a2f2aaa5f32d52a8b97172a03e91e7b9c0fe6ec9da2ec32d3989e159733aaf087423af58d8e2f0d7280ec8fdd0cf2d0ab0d3cda3e4e532b96e6f7cdbcf01570edd383de5d60dd278c3e4c69b185cdf1f1bf12440bba9649f8d61dd10f837adaa5e1f5ecc4d6c7dfcff3568538fc63fd88b42d79ce52138a79d7b567b18449994c97638b6ff0337367cbdfed7520e6dcd3cfa56215c10e2f5d342f114105e7bb12c42291c979afd57d35a0dde71f3f5678c47908b107d600e8ac31f0817d19ed14c59b7de83d32df8413ebe56835e3df4a3f42f09172e6055e566d8c66bfcc73c3c1b9344bb05dffc89655a36831ff6906a10a73602f818f9ead4758afaf9840a153f5b169eb659f8266e59e61b91dba2f6b0297cb284104e4fbcb0b2356434b577424933905d1414c71faa5cccda1115c57d4acb38a0d6b9d34b335b205da960fa960dac31d65f08e5cda95f6a272244328af397456c9a081102b62bd2a2dd81d9f4d27d4b18440666410fcdb46e0d39b201e08e0e245807ee80f18733dd6181b330a840aaff83c9e6e5867fc4877793c0ae65f1173cc7deac8bcf4d0f8c78e111f9bef038ba5cca44ade71ec8996b9d49f6a7c3502378df58e0cfab50662acd990b10a58c75c49cc3f4b7211b01fde6e76fcac98cfc9981822d9de36f6284ee447d2672570439f9cee3dc3e4a4b61851b460be49ea54bd1d7567a957b3a0a3e82bc023a4a24bf953872c408499c7f27e7728bc88a8d18c6b1c01085873808a5dba1748ea77c47947a1f58e7e05b03f18de45adc1ad233ace563a22494b61bf786e233be08b408713455bf30299a020280e43ff76ed16ec6bfc32e11a6cb7ef1fe5adb840e5e6734363e36f89a53c02516291252c3455edfd7338a019b89cbf5e43857132c2729dcc643f2e5d037556c7bc123a94f8e92f1e103ea7146302e2d6f11349cc188ad38a6829ba64b652e13023f85e7d00bf029057a5440908e0501196cedfd60c10ad857b52201f57e5b896d784fc28c23eae4ea844066f3ea9dd03b115794a0cb287c458e03a9f41cab921be4f9179c2ab77205d0423db1e3818087b9b88a17352e3934b1aa6e0b5fb150a714c0d68a9a6b414b3d6f7c2b1bf2f9b0b5c9fa066a6fd00d12986a73b785313a9596117ad1a1a751bfc806d1ffa7b0aec6bf662d2a6a6602f947c7db96434d03b49b8a76870b816c51c2da25076003faf69e38326b01add4479431343734b8e98125f5f1601b9923e9074f595b9d4f08d3013f271c7c6187b7fb8887b4056728de96a7fb67a92706476f702d0d72c1399592c6d78e86fa19df82e9c40d9de4f556f683b4a4c54a73105921638073e0ec740c7d99830d6064fde305d8bce4fb379432aeb65f02097f6048db28cac2ef438de55a9cf9d0bc22442eb78872e62e4677445d5903f703174d85b8bf918cd2f7f4fccf5085c3a1e92708c1ba8b328b9a181e30bbdd27b5685164bb2ae1367398f22a3884523cc31f4e2edc1e6643bf8943fc481505f888cc3598286f655793e1c534fdb926963ff09988b467a2e6e1f58d934a985edfc5420cd11b8f262b41ec48f104387f4c43d1f6432754e8ddf622e1221e486e624adc6e5142dc7313e67bc8f781b3e1dff478942a012ca86a97e68d515304c4776a0171357394b1536c449228e3c64a369793e55c0b7e95272935821dea949120833e7c0864332679f3afc22e97d3fbb91323789aacfb6ee5e744abae1c6dbddad28deff1f0519197986ff4b765cb4b62ba8b29eddfea145aa031a522748b1eaa8499431c1863d3613ce1b5ebc54bce0e0f3b086b46bbe5e2471b68aa4fc95fa20ad8a488cd3927b9a71cba6d30b1f7302adc02d811ecdbda915c3fe71fbe9f36f0b46ae59152018dc6cda25602222270aad63bb87ee81d9528a2b5e6caee8e0c55ab1cf5d915e82ee3c0dce55578f8db391e9b1b3c87ff6b660331bbf9b7b40011986b91777070259a440858009843fcf08b5cad4cd6aaee0bd8b9907c996c7fbc20095bc3fc597645432ac169306d4885e701d0fcecde037d4017f5d13cbacd047b13841ecb5c34ec0afe78687973017580829d8423a930307dbf6ead0e7282ac1200f468e73d5c3fb65dd3946a415876f9debc51163434bab232ab083fcda1b319cba88a043cb8e8465246bfcc062109b3f7df12efcaf73883f2a6c395285463880b5feda0ef67a8c738593e5dc037b54b17757d532a4279687274e0f8f2c13d5c7e2c320d7543c877959b82c6803d3bb6e424fb2746e2e16030289c17540a3f39082727a83555576742ea169a477f5cc91e80ca00e66544ea48d9dcdf957ae15cc2071c73ab90b34a2a88c17a8d1522d44489093a0adc2535afa2086b1c2c1af35ca80d037e3de1fdb16c27d05afe7f5e30d4fc5157de0fccaea469476fc55bef09b89c315f891591402497a60c6ad8849ab0d440923fe853b50a3020a168d38b05bdebff1c9ea902715b8b96988ad28b089a009c61791ab31d8699938a0461e604ba136f5c53fe1e602cdf90cae6473295c04fbc92e92ac8cc3f85b20df03d8c9a297da5dfae43bbe95e98c2c16549070a29e50f280b7f39cfdc684d722b2ab6b6c1c54ca3faeae285f45aee3f695f1cfe3da3ca9ec402909caef5e25c738a5b90f859a267fb50563aea904338ed983aaa6ecf91b398159160fb576817319d50227dde0f6ae42627b9ec728668d6b0f91d45f5dced317ddc6be03a2ecb08f3aa58dbae2e8be86eecb080d1e775ef60f55fd7f07df75d64d0307dfc8a2fdceb57ddb77da60ffdea241c63f42314536d9c0e595edd2c8abf753521a645811dfd32c52b19bb3fc13e9cf34da5d8b8ffed8b54097e3c33fab1a5d3ab840cdf9c063ee29ac7a2c763774372eeed2c812cfb056ceee8ab890294eba9b679491ad591b841089b1be1ad7e8200d70dfc772a90593ec93533f16e5fa26e392be4930ea4ab50f7d21630e16b1407508c3132c64f0942a187180931899fbb5641ef57e01e90218487f4ad89235a7e0168457652c5dda4785e1f6d9e8a7aafc00d7d3c072dcc691e1116f9c19e5472e3adc2e27bb8aae859e2670e7c4698a54af7d05af33b5a0975b2e78256f34b152e0b159c8b3bd0c815ca0caf71dfdfedb69dd09bf407d432cdd7e66528d73b1ad810d7985dbb3a09b836337a256c304cabde8dddae46bedf962002d8dd0865abb73b69d0639d6d4337602ad12cf4d2a7a5f2b57958b68dfe7a6ec36f060ab9348179abe559cfd4f2c5ad59de9bf193e01439160bcd81f6478687bc10d76b3c088341778d97a58a2e163ef5b4535985b1d0044235621e6fe0071fccbc60579c975d200b005ac17eba5a6587bd6cefdd9743cf74aca16df15d1aa1da6d499fd10936fc08cf920bf7da4f786897f95e2e72ead01ff13507f56d1e6b9b80da01ff5e3d7e9d68ce86407ea6798702006b5af7f70ed9b013942d85d81037c071dd366f9e9b4b1c97c3e69f10d42009db2dd86ea89769e6f6ae0c775ae15ace084195fcfb72dda6134360b56a5b1e43edd445a9e91003e3df6dd2b0494ccbd8f4ee0192ac956af0cfe2f7a9c0dcfb6b83ee74d6c61de18f4e31aecb5b8a0ffad1e94b06405c4b8a94fea2039b2dec0f9bbbc6f71d96260b8bb10b02de33dea062ad7f4c32bc06eec2ca27fbf1fc92fa61064f09c26618491e5d76437c22c219778145e98723dc681043ffe9f08c750614ef4efbcd77af0d2ae60caea6d411410ba7a941e4a6a0b2979d89a48e00dd93a40c34065c94616105c760f8b47a7d08938f34ae18f8e103b20d13cd66913321abd9e26f6d20278f080a6cbb364ea9c80322e480b1a887e4af68ef5b332e1e99cdc43d4dda02bb32175311ff57d191cf05072e77012c1b257536571b1084914f50b60d6945eb68f860ceafb66c4abce4ad486bc093870e183e0a767fa510521a958b2faa471ab91dcb785af4d1db851d5b04034f1a6e7363ef00ab8e232be5c1d37ba4","isRememberEnabled":false,"rememberDurationInDays":0,"salt":"fe947c2139c92cd75264d7c15d580e6d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(passphrase, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
