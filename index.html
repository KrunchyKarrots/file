<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Access Blocked</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        body {
            background-image: url("https://marketplace.canva.com/EAFTQEWI-Ko/1/0/1600w/canva-black-sky-galaxy-stars-desktop-wallpaper-iWMZ0xN6KXs.jpg");
            background-repeat: no-repeat;
            background-size: cover;
            background-attachment: fixed;
        } 
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            background: #00FF00;
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #00FF00;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: template_color_primary;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #000000;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: template_color_primary;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: template_color_secondary;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Access Blocked</p>
                <p><p>Enter your password</p>

<p><a href="https://krunchykarrots.github.io/yYM-bk4i9fv-x8fuNhY0Nng5-LU-F-8G8g0ukOx-ONW4zVUhNL/">Hi</a></p>

<p>Click&nbsp;<a href="krunchykarrots.github.io/code/">here</a> if you don&#39;t have an assigned password</p>
</p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="Access"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = 
    ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassphrase(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())

    const templateError = 'Wrong Password. Try Again',
        isRememberEnabled = false,
        staticryptConfig = {"encryptedMsg":"22a7188235972ffa8c86f7ec8cc44d8521ab154f7e65d50b3cf9171ceb99883fb35aee79eff1534a09a3cbf01268d69fe8a6dfbe8febdf2dd6a3c63a5da7c96f8c4ed727914e6f5967c073c0e589352617ff94a26f28a2a7f378df4a90dda4a7918d5b3203666dd115f1b86cdf8647e1535a5909abd615df5e6d046385b97af5921d8d16d7bf0be47b6a745c183106d6c7ab1e38c5fe38b7b5d8ad34a68983521be04a7155ac6e9270a36b00281ec0db32a7a849f12b7b93538727f4a91c6558cefb5020aa7a076785e6006a8fed41dc313da1fbb18c9a5091a2cc98d6e22fa5df390c5f485064c29a3cc7947df8382b4499102cc43300f470a12a7a5627c114ef8970803ae36d3dd0e96ee3f2950f42c2c250d08429269e0e07b7c59c0af72cc53c0758631a0f4360de199253b6a6fb2cded629b0a75844aecfc6b2c284e85bdc035447c2774e7535c5d4ffbf21cc4e2ee746b729498602361ca39144addef6944e8ed2601fae3a25b6e7dd0baf29f614228e859dc1e73759682615f8446891cf2955cd75c020c0c1486f4ae77ca005f85e5e62f799c8c099bfb4751bb52903089086f142a0e13a8a73ba7a11ebd94d9cef41810b54821f57fe813c6ae104ea2e85e783527e9f9bde097eafdaf486250eeeef88838f8f7a794102c2fc6c57c5880a9bc839d344b727f39e723b9f398d30e037529e9e692aa0878566cf5e92c5ed3b4f5ab4b38018509cd08d3f3fe2d38f9f70a724a994927b68c8553cbc07e25582222864ca27a1cf45bcebb7a788811b754d88bbe3d5e6f7bd23454e2bf4653edb3b07888b80fa85ddb9bf0286ef0b4a289bb5d03833a1ba36cf1cf22c83041ca9424dabe79f3ea5e113eab709f3a81d11cde36522a1064108ce46855e7a40ca2ba70fcd61add2f5705dcc7976da47de261e3c447cd133e5f0a0fb15f6ba53e7592f8125ecd996c5d75c0b53b18e5b59fdf2800bd5e6830d421651d4be8514b74aed81daf985c0848c27c38ce45ad14f57e0adcc8078903c5d842a130c3e5a9b6ed325a06190a487daf92e246fb5bdda534cdcaf92d97fdd30582df4b4d22d6a33fc50844536888095c8a48e40c89794f725c355ed0adeff83d0aef0f6a233948a3c5df925ef80ce901270dc447cdac2922d151eaa7ea05a7a76ffb42029df1b4abec13a53f8b1a5d0a6d359cb32083c37e18400c8baa56f32a4fa3fa1442fb82f3b0e802074397b3b7b860f25de20b56b8568503283f52125c5f09d136f543feccd1ff73c23f9dc80099347707f52dd5313904c834a19245e842c06ac1b0f0654c78bf178d25dd6474cc41263644605ed8171154fa7b29c2c7289f1f180ca06eb6bed3ae3cff70197fd4aeb360f4e3ca600a574e24c0e9906f20984181d86ed77dc3eb1ab5eba809c9ba484905bd1b3470d8b1a91f84b783e1ae4ef8bcd5414ceb6fa8248f904c3e470225d00b179a5e696d215f738f798e60fda306900152b472d24688602e4608f0632300b291ebb0603c517ddff2c4ce1da93bc8aa4eb79098794282e0c3f29d99889c3a242b85545655f03e233c4644d44082b22bd11dd4fda37d28ee73a63c4ec63427a1df351b18989091c6af764fa7d2c290e18309151d999ec4768b8bcce8d0c228d6a82f04d50506752eefae59b854a89a708ce48e7995bd7ed44c6e60061ac33538bb2a8a22774c520219c19da62022593e9307c01a60bf2f2c8a4dc0cc9ac353c00350ad157b853a4b3262c6707d262d0b7f674630282da2a3d032a3e04556fda50ced9edc7cf853d5fa84824f84161471a219540c6fe3c634e2eeabc093ee0a9d58241b3a4c87ea9fd6d9f0b8b7e4c8ec0127932b7b20c5f8b029ae249618f2533c3ab07c7c7ba3250a29efedffc8ac259c3cf7e35dc22234ad38f5963dd0cbfca32ed96f8c27dfe5040d779f764cf62952ed8bc93f86d96261c3e933d1b92ce52367ca3b058f75ea7e9a763210ca0627a7c89432a39d27a162da4420d914893c32538918f6774daa3287ce5fa621808f0502482f1bb26cf174ed7da8d9f8641e2304e73ea0c87e5655f9e6d4c6320fd6d358acaa37897399f6acc5c7752b8709fcecb16f58f0863bb030421a30d7e6b3a809c4703a27e07775e634567dd698296ad12d25e6328e7496c11fdfff84eec70e8f221e7f3ea385a1173b6231cdeb4a7b11a0fdd00285ca0f6a2f6177f00c81a9f2e4020cfb09467b64083a123d166a06721e5fa2c8d7cc671877cdb5ff114201a68e362195979f712151ad4188cfa092ace024b670e00f1aa7be653a8744fef53f66281fe5f6c43202c39a0ce8c9bcb1b06fcfffa9b2c1fd7b8cbcc7855137b0b3664b0bbe5f46ddc942684cff0370bd60cb16c68b30379dbc5917d58ed196c4f05957fc36221c57d957b8c672e8e68c9a12b4a22e4040901fb55b7e6b7a52df06b04d10dc70f096727c315744efb278f23480cafabee464c55307a8f7da7a0e325314000d92ba4eaa4be3bac9e961231d2b02eefef3d46a7cfac6f1e2bb22bb14afbb4a15cc416d2b7b04f6bb62ead11f40846a257e89500ea1463264437ca47d044cf5de1557d0c1ddbca274d9dfefd7b292d998680eecae46f34e9f14194f42abdc41f60df725c0b259cb0bd16397fe2ca2d769c00be51ad045f705aa4014a4756b86e8341666c610655d2ec8da6e52c480e4bd0669c5a3f22cc973942494069b1a0f409d9562c0e49751f2772680b857608659912c3cab7d502a7b2610feaf303bf5e966b66e57de940d5c6b5f404739dd6a2a290dd30566f448a3d7faab471b3f1e41c1cc261411c3e66133cec2dfc6352ee61c866c9315ab7d8d65cd9fcb219b67a6de75b9db0b3d025f2a30bc8c5bf05cc94cb247db80b31f2abd7c1163815a99e2e119f29923b48926afeb76bc695a6edf4d382d08d3a2888a552677159efdd719690ba0f58848be5c6a4747c6dad98f9a635c18a0fa19b1fe6ddbf68035a7e5346fd8ec7df4b6dffe27117b8c79dbe8ab606461e21d9fc65e17d155cbf83ba88e8d4a94d7788c266b433c3ed7afba7f480ce86afd8d045901ae89e1a0681dddac9891b88f677e5572cf0ec5e96f36cf35b2ef164cb3ad6ffb98ed5f028012e8e6d43214c17b9b04a76d0d326a7200b3af7a4ffa45eaca3516203f0c80414c595fd30e855720c73c5ded8647428e40315cacb967b022b0ea05ef2b17b7c0fb274d1794ef0e5bcba823f5240f65b163ef32ccb0a8612729b9e0014afada198d1d4259e10f5f0eff6928c9d1c566128f205cd8dde3c233b95d1db1ffcfe72d50b54eacefe430ca7f613d8a7169b55149844bce7a4c84e17ea4c2f8e9ada8c20267a3137a9d7dbcab408df1051a8bfe52e000a427cd47c73fb8f176e7431db21cdc6017cf4ea1f0038c10a5ae4f9b95fac1f1f3e9074ee455881063be0c823a0819f352c23dcb83d54cd12573a5f8510a416a5c77b9372ac0a4aa9178f4e40fd55844fdd91a23d32bb2dfe35828ace7b0949cd985895b6c116c3d2af2b2fb4765f906e5d63dbacd9f9c28851e6d358f3801ebc776d06c9a0c8cec85a780206b6ff8a240ba93ef38476c0d99df7c412045c6178ac9dfeeb7b91e35bc716134f97d1957b59fb4434a90497770d2bf5c3870518a9ad36693c1b135e1d3b4b76bce5f8955c5c427ea0f04e45729d85abb0ab209a58841d0443f6dcdc608c84d85f73799e89dc1431f771565d66801ec756c11ef4b417a4cb28f6a41fa53bab944da8e23286e9faa1ef4295b22d8052e459c80af676a1d42eddc1cfc1a88493071b446d4dbc1c1b042e96b1b23063c10ddcae3eca5dd55cba1ada46357ad592edd548253b5e83f4a50f8e743b222beaadf620b9372889f07f62c314a9cbca4c0d8d8b19b500bbf5ca49c39cfd6c8a045674650b7b19ae522f01f038974bb8e83725892d94afbcd4d752ec20b743e74a1c675384d56d27ed812f94c38ce5bf913eaa88613bf2b2a064b1aba1133437c6b8ce5303cfc141d1d411f8439a41220cd1107a2a67f62fcbd2b2c7b114e14a430ec4baf1ee4f765dca34bca8bdff9cfdeaf7ff369baee923436abd3b161554309148217cd91cf1af4d3ad45c5035509a998fd0b1a5414d0ef7fdb5d4d12a4e49474d49aa772983710cd267e4e0cf044775d17f39f62d190f2ed4d2bb078f46bf8c8a3ee633a26d8306f215f8c775eea96df4d430b069e453ff90f928620ed4f0e57f4d57e84383f043098fc7e26f4c004557374a7c195bcd3f75ae72074de453d5221e203516bf0cfd71eab7a56bf6be53caaec3905633ecc770f32fcdd9ce2da119f9d0fce24367e9954502951962ff369b4553c2b5520595fa9608bde029388bb9cdfc61d310d61be1354f23a9a62e0e37f34e571e32240b6310859bb8c651751c734163f38bf1f1aeac0ffe3b2a32e30a5aa583175be8741f563b9f44d9958a36516ce7e57571b83f89e24705e5cb68c94cc0151a91f397bc7d0d117a297180173c904a021850a9b04325758c1222932fc9126db0730a3899816862c89ba5880f850b1230a0210510b631e59e774f9663abd402476fb6bfc2300af642a93c80bff32214ce2fd5fd80b30d0ca9c8648db170a4a6c7f50e68a1dcde52c2fe7a09477a775fa2e5c01cfd405948111a6a4fb11fae355fdb5a0d3774fd5d56dbda97aff49225dab9657d9d470fd27689f1351565ccf2dd4d4c576d8997da7bf67b0e242c8213d075986e28e3d0e85081089f0d7c6c481b99473f62676c0e5d6a76d337cef5ecff0f252de255d647e198d8578eaaa7b36490f42faac97bcd2a81147628e002bea428c80bf657b74913de0cd1607850601bdbf83d0a140e2ec294693a66c045b8e7f79dbbb781d18aa33622f5dcd64ec3d3224a1dd9ef3ed3519c31f288354f1b3fdd7a1d93f7ae7b7b20c447ad532b29e50bcd1f96527cf74a80d3a4dcf69e80a8dfe2a7e90f28fa64da116d6ba9e1b85c74356671371f21f77880614ba26f2d2770c7810bc0f9bec092491d5c860005e573be1912450eda317ce955f1aa3063e6610309075d8cdd3775ecf481fd2e371e9429270aa3ab90cd2cfc496505cdaf0ca2af549c2c7eaa36bc5502853ed8c5cedbf08b64cb2db6564c087767eb297172df8508c232d0f26ba0e792f1563fc50dce60540a4adda5bb2f565640e23eee56cc57b229475e92ab180e517083314ff174d17fd35a24ebeb8469916e8b2dc1cc338691ca56cebf560df21fc372a6a9d2427bdf994394a1be1ccd6310c345baf91eeb891c4cd31617de34c229fc945a82e8fa9b2eea3477e7285728e21f0cba21ef6c7e90026fc4fd1806d636ac81cea14324ee673f55a6b65fb831bec785ebf4b234ed297357da698bd48394c19307c92124f4fa8ad54a3540a942fc0503fafbad78b30a13450f7a6276cf6fe91ebecf1310d031411cedfa5aad924e9235c3fbd1cd02431dc387aa61571893d598582bb2c022119de9758d02d90700a80d652408868408b008caba9be2f4167ee27fe1abb961e40626e028b8a43c39ad587496eb0ada0daf43adb35774b6f004dc0f5d75bb231a45c631eb2c915af8790be7b193010270c362112792b6f2a8674886d7a0cd4c70661106a17bb4e39e249d149740aedec4e8fd02762f1cf610591c60b907ff30281405c03b0dba627f72348ea5cf0e113c11f22942e60b65a1995528d982c1fbf6f115606cc6b8ee0add93e41ecd3f0a2df57369850071edf6741a2643a7becb5073b676c977a5860e5c27bd761f03b7947cd6e67a9d0083f4cc919c5704032556dde94ea58adb42a0d9639b51d739b28a5e17318b9e32e2fe08708bd46b3a930ed02ea306d655c6a54556f9aea6a8f4670a7d9d09fdd502b7d79bb37434db213ef5cfd24404d8a4e1246fbfab3d7057e588da423bffca3fc57f58e1e3dca2c6cf63177a48dc81c22dbca1a2f80a82465329a584baf75063dee2fb38914885d822f9f647988940ec68a104050df3b8db927177b80bcd5c6705cd808edf776c38a30f933ebe92bb836d66d1476bdf938211be1f1621cd0706fe8d550a8e405cfcbb7958242a0d721db259ce2d2a0b542d74347235de6653d40573becb3fe566b4b5381a49ac623b8d670c494f6b43324e6ed42732038dcccc11ebb9481a8b76e70d9971cd3f0edd036192e6dc25bbbc758b13056c67c0c056286fd4725483d87f0d3565eb64c593a133a94b3ec5e079a624a720f45f8859d08a4726077da6cd2ff649adf7aa9caa185fc9c607049abe7a5f7b04e35955098cc90cac7e408bc40656a5ac30661710bab16f0ce4e35c687c2c24252db2e805eb649f59b152e6d3cad3493392ab080515a300878039a427b6a3fa106617ca5002fd971297fc1ff0205751d4196866fbd637e167ab54e17e7956291880a200dcf8d2d1d01684e57e29d0236358f9268f99aa5af71d3296cdbf8e218b26eab2e59486d1db5f1dbe75958fd18e9e3146cda7a5027565805dddb78525e98502b414dbe7490e96847938d6ff3da1eb0988e1dd81aa84def11aaf43777115840fa8504021b57c5da1859450fe17d9c1a83de3d68e0788ee5935d65f7ea8a68765daff5db4b450a6972ea9bb396f8f368ac158d4bf97fb05a69b8477b495f420d5d54bd006660e54a370cef790e3d88301c10bd1ffcd6b40b839bf4e5fae7efbd5a38a0dbd6e45d585a7da6cf79e4b78b2c70a7a3f815be2692a11384b1a2b8144a190f24e8adf7f0ea08728458f0c0ee3bdd94322c22a152eee15b35e3edb3f050a484ac9bf3857af432b00410cfaa0b43a81cd923b17250c1d3a98fb64692f0ea380009b0883f52027e0500e6993f4d6f40eca5f711211f29637bf0ad6544b516a2b96f8a96b23bbf9eae3af5dfa75e8e899e90311751fef7079e52c59873c0642cf6ad0b848e0c691b90ee6041c0fae50e0755146a8e9a223a07638db98c156eebcfd25a66998dd51e1d2ddac8a432ee8ae82bfa35d0ec430adf6d07a68be5acad1b4eb9ec497927142999c00143d26bed862a09bc6d6a67dc3eb9350ea450b20edc47735db9902c00920495fdb56d4bf33f75eea71bb0300528145daf58bb49b10bd8d5a5d9e79bc75e58883ce3e86c2acd07a752d7bc4a5a2d5c50831dfc63e5108204cf4da50a8b1587b563854d420773b677fddb689a5862fb14364d18801063b1146db4520bd99199459a6e07146f6a5b1e3865b99a0dbadc68e06d415dfa93e3138d8e40fe119358be398b9cccb0646e3c8cd9a602cedb3cc0225914e23734756e8e10cc96cf454c12e0883702b32cf1a1724784d456caa8eddcfb4dd1f8bfe86c9ca8b35919b6e4253fe4187134bbb62dd8e63caf14444da0bf5750113ee3ca976670db80b50447d0aebc82a4d4c38249854727f264138c35ad7befcf1321729150f1cf2e51751f9d40b52336c69cdf8d109c9d5db8cbd96d1cad72219bf6927bd74b0084bbdc398426d9ae94332aceb6b38ca488c34d4b742adf6eb90648b57c6439cdab460c1c9d8226e46eb6791aae4cd55bb18e13f2e7b3e3d0765c2df1571c4b26cddaa9b3468e60c90c8b71b65ea70805ae33102fd44fb111aa3ba133d324bd6191da3ddfff9bd88f1b798e9f53212668a4d15c047144e7920717bbb808ff72df128bdab352d34ee94060227f43912b9981061569e0757d2fa7066acd42f143085dff8426b3d72bd60547f627a5389d0fc48d18b0976f620f5cc9f0d287d0772a7d369440742ac17d1f15859b30652a8e868278e30edfbb9b3336c127ab2d5cc5a6c56d40527b1a3ebe2f0debaff09cea59bf7d819de15c78985ae4ddf412016e67483702b75f33bde996d03afc34ec9e1b6072379e8f1a3b2f8671382551b2bb52f20be8ac47095520a656cd86beca38b3d3c1a97b3b0677e25df3060251a2cd8d5a809133313cf33e86f8a696d7a0526fd6ee56a862c1d554c2626dfc77e59e1a0e28b7423b63fe39812c2d98ed37bf61097df5d681a05fb08421b402536bad125f74dd0785e0422b0d01a563457d0bb4c444163213a6999a17b68bc141dd1c8fe7c74ba69fce5ceccd7309cfa81d99f5b0db01a794137d73e602ec4009491ce9b80a3caa6ed3ad43e9875533abd19c9416a976a630243baa362e25e8665a159bf132c5f96f4d09aec189f061eaa651d25369c350beb5794211dad912bcc6434eeb080fdcecec9021f7e6cde7c95f9f877679f734d2cb9726ce72ed3a626fd4f364eb21847ad5e3babaf77221b4f2fd982fbe2c184b5cba65955a9a55d415489f4b18043ab4b8cc7cfaf34d2bacd755bc0c411e260c5c59c3c7532ab21040d4ebefb07b4a01956913dceeae9e15af3cca7080a0c14c0db92fab5405e7012548ba6cc1482fe30e426a5a33eea7530d1a3e9bd24f5995ee1b0c503d11edd11dd4ea77d06e27d502c4d58ebd375c53cb5a810418f1a72169b2bdc0d1a3821c4e67ed5e0c636cb60a9b0aec933a5d3b607c6eccd06d2207126df81d79eecfcf339fbb5be01605e3f60af9caff9324c1db31c0c855d9cb5929baf77ab9325d003fa7a6a6d89fbb6adc22c492ecf99366703dde07cdf62400f4c1970b3beccf4c9a00671a997e541ab60df1fdf2dc1105d166acf43d67b0d50d01bafc286daa30b0b7426cc463e63d308c977b143c2537af83f6ece18d3d85375965e8920405be6d42893dfd7f336e7c0f0ea6d703d96d038258518d2beced10dd3b27e499ba72eda96845fbb7981ded594b0d403496560bbe20c74f8fbf14c7b507df0fdd2a24c77f2335c4cbc22f4a392bad2d246d2b8328281b40896d47dd0d07f175f7442d7b9da3c557b112d11dcaac27bf760fbefa38d5c74dee2352ed9f6d9ee42ca215c739c6a6abdf740283c027552455d3f1dc39c68c8f9a96c93dcceda0ed49f40160fa468a7af33636c45ce39d4614416fd33fed6f998be4931f86f949f1ef76dbd78fb0bb37034e8db672b32db88f0e951769ca82491ba3778252232c9acd295feb7d1f35f48c52c66ceb1496e8fb330cd1b6287c05acd86b0dca7ea3224d3e8ead061e6f7ac16428a273d04c5a25e594ba6a00bb6159e3b5f1315643c7989f39038cfdc25da0fba72fadc4ff3489c831a23b2ce59b22e4ce9a787b74aaa17fd7ce7725f04ee34bbd72f377af2b653b1d847dc8502e5388bcf4d3b965c8013dd7d06a60b39b6f818438e1592f3dff6cb6fe1a9793977584b5f12f274823083c2743b69dd27d42f0b1dec946d761cbf98dbd4d49c3f449ce04c785620e984306f04f171eba174aa45996353309ae3f9f57ea77de601af6eed20758bfcb3ea94ce4d7c8fa9bcd8e1daf8c13e044bbd311cce6e6e223e7d10c13bcfbbda38d1f67e07f590d5c3284bb755a0c8f1a57c074e23b63b14ad58bd4188151bf091fb6dd198116018530a3da5cef46981a5fdfdbca819ee94c846353c7201b557e6a3b0976941212cec5c4083b94fb5500398c2b62a26701b73aa7233932e4f424767c46b02398e330ad353b70385b0e1401eed8e31e30e2a54dabe4e163c6f07306be510fd8dbcc82b6c47a4f490dd5be517dffb322b57f9f6f945e56c4984b96208ea94c66bc91259c1a9ca082352248095c45fc125cabc8112672f98e72edb4a8abf0538de817fb7c382865931e0dcf375dd887cead35cce55702f1c59d1814abf2acd771e2a21a1636767a428af8880010e4726b35b22b9fa53ed2eb050f15f001e5331e3e66cf727b33d7dedaa683e3b7b7669fb29d72373b70e7761ada3adcb033a5c7ec8ce4d85da00ea6169772473817d3a953d16c35b78b42df0c22b59d0dc7bdce9ed4aefcbad34e00495a70edcfb07915af1940c2c82920a144f05f8232327e9bdbc2f9539136de835bb4dc8b178aa2b00074e2b9f06ea4db2110400d4b6f8ac4846c733d17c0c91eff4510bbeb573fece9fea019a85a4bc544f42fa3f436ee374d1b29fd4fc6a3569c9cbc9cd1c3d2d3f6826f26085a3b18d2ca840aec6ef9cfecc8b15ec6ec8e6ebd143aad5","isRememberEnabled":false,"rememberDurationInDays":0,"salt":"0b49c64684c9bb94fa30617ae3a73322"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(passphrase, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
