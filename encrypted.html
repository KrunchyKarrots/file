<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Access Blocked</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: template_color_primary;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: template_color_primary;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: template_color_secondary;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Access Blocked</p>
                <p><h2><big><strong>Please enter your assigned password</strong></big></h2>
</p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="Access"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = 
    ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassphrase(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())

    const templateError = 'template_error',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"65fef4535b987c6aaed14c502ebb55bb6a357ee3e6bbe1841b4c57b764675952d744bcc7a6d972f857374849de162c9d3771597f59d2105b5cff764062f941789976adbc66b5001f861a61c87ea074580243b37dd3a0801127c926eed7972c3ce64cb2ecb57369fc2545a10e3fdf9a18ef6fe64398d4832a81146932a012f9bccfdafdc94c7c454315466c8d6f2e9c19d7f2e62918ef54b9bf301d0f32987eea29982724995c9237d104caadcb27f4ed9889153a001e9d3d2dac47ed41ed8ec6efbdf3542f43c6446bee260187910c55850889bc881f2376ed72f866eeb969bfc9aa77f93fe15b9bd7d226abf80b2a24265c8d9ab525b52ad25bd00d6bbac5b908bba9e4600fad7975224861fb19e61ddf7fd10e5c9fb70991bdf9441abcd5be068a0e2fa0d253baadd91f5e96e6bde187fbb0f8f2f181e26a24aa32d0d9dd055a48bae46d420f2bb7d13cfc24daa481aa9c7c34c6e2498b5b1917c09f16152f75ce06f818949303264a841bef246df9684d5a1a279273d42c6d833d6fcc55d712f1c6d51f03f76b409fd81b56aa495f45f4c7ce33656669513346582a28c0b9cdb89d952a5ae0158983f9178eb5d315973533f0ec3b3e0035902dbfa3fa4190e572a582c3c0b286b85a7b81ec638760bdb1bd79e058307134d1d94840aa63fca35dadcf4c3c925c64a9cd56d5899e5c0789bea035d26e481c763ed5786263091b216160212e119f1c929657ee1cd6cb08bbfe6624274c5abfda2b37908ac4ccedeef708761094ec4f148d86600c47fbbad1a40e983135d748506bbe31e575ade305650139efe6b67bd9644d3038913dee5cf360259bd9ae2847afc8d640c5b6adeea3a275cb7c5f2550d8fbe4ac94c0a470dd4f3595eda9484bd64bda0cb336d58320f623133709a1b47557f8683c7636538f03da62d723b0c149c845124841e9c51985f28af77eff47331fbcf0f30684595d06baa41cbfa27eccef832494db389b73bcc4b664b53a33dd3583e014b2567cbccb43c7ef14ef5f20fbcadad37b3da1a247228ca7f05e16a79186a734569fcdde4d6033c9e77589d2350a53c6fe83d895ed75fbd0105843fb2069d6cbd8826d4dc49e6431e315b0988f37f060e3fb519f6a00cf63443d119f485f67774c17dfd0183b58f46121d573aea5b91184a3c6bbdbb18ec3517bec3fcf318ee7fd71ab2530cd8e63f2aceb645ac89876b53a3abb5f0986645201d43127af15e6cd2f1339178177e14f23408a69e60b5bf741b9b08723f47c6061561c04769ec4a997ee4da1de59e1cb5a224550f26d14c98559554d8683f79cc9156b246feb59553508afe6456e3a396af207c1f1f225772db76524bbae61522f782fab9e0dacffa6594d560aaa46baaf309d60074da0bacf1f7a5a0b5685b5ddaa4d9fa0667ffccd18fcc8f536e73cdb5a0cdfc1253a4869a8f188658334ff3719954d963a7588646700e3517c8a0193296e4348b112a7769d0bcbfa1828d7d5929095624262fb0585ea6b0ad4de15a297ee4b2476449ea9d80d166ce8d1ee351d488d859ddaaa62d58dae5e0afa0f838292fbd70bc0fd6d9e0e3b9da0a67ec94cff8bcdd77ecb1d83449fc899812022b62737398b45aaf7dee9d5cf38f3624346cdfa982e68e895dc42dee51bb8e2b99495dff5d67d4a0fc5323f9ebc1d66597523db452548953ae0430ecac948927ba22d54fbf8bb253e5ca18714607d662154009cebea78647ec1cd625b6bf9493902e8a402d841caa23d46d7192fd4fe5bf217e27c331469337940fe64472e6167960959f813b18df7c4f7124406cf1d7d06c98ec913c2f7cdda2862d68eb98e544e4df2c0f4af749378b86dda7d56e0d337aa1176ac27a763dae975f0397eb8baee621532778d851a43e121421309c2ffcc1038c38c300305214ac25b1c224f1f6f3cc9670187f6c06fedac3f4c7d0a458baf374e99c351702763d6dab194584c7d98d75a260c3ea1cfb446e5c6533245e948bef4458258eea2bdc7966bffca039779b4a83bda57caa004d40f1ac50233b2c6417915b49dcccd2c77b74e3b975049ad818468b72e792a2a5b180508d75cf8f2fe9d8bc7d47518bb8926ff547e2b77d21f09523ec04e31535e270ea87bde4999c34aa520d7c43056b752257cfdd145a53e0a6e6928fe0604355b481a155bb4d05964ef49746da2417ac7c6301e75088ee36fb60285cc0f252799a55253fb3c9d6c3034ff27808df142445e995d411f42c28a019e07de6a2634fe239f376e4a8053588b1b4c9bc417c474ddbdf536498dd7afe41e0e1f1dd1edafecec3a8a2fa794d9b19cedab8268fabc2787446768517a9f33c0ad7f174141667316b69f93c3dfd28a480c6a971ec9b3088642c521de980c326308634f55c7efd63d3534d76b7e4892cc932680ee1e7dd3c053ac306babf2d741f56cefccfe7b4c52398eecfb6c4745d2334c944ae2d4d843af26ed3074cf80a6e2403b0f51d9b43f686d8d3dc1c57176cd12bfadeb493515d90f3ed52577f9695911f4b549c2664d519db401d2cbaf4556721cbbe0e0a6fb114545d11b6dd52229214ac9bd201533d03b7b6c9aabc152869dc28dbc697ff009a912ac435966006ace2a29373b33e0cb12ea9d846b60e5a99554752c8b44ca5bb498630b872f7ff6132951ce09f916e3902be94f4cdb4cccdfd12fe7ab805e49f6bc35fbef0d3a0f532bf0971935194d67ebcddf4f03194ae235868ed34c08427345356878b05d45dd64c40a4299c2a69566d60677444910b4d1af31ed2bee75c3e9b21d9c11fc6d1f69787a3296aa7ab95a94111bf4fa4bf576f9be73ccaeaddfb81adaaf43314b57ba88cec4b2aa0a169c373386df25ed53be43ee6ca91fa9eb0ae7abc8e9f007c77152ad5dfec3840a4f1ca7b9564d36ac3c1c68bd3f9215dc6ac8b63acbbe54032e65f164ea2d04be4a7babfccf15fec65ee7f2e53f0826d9667e24acf2086fa9fdef5a28892f392e7e7ac1c676d0ff03eae07a4980a2ef6ae5c0df53b5c0b06cc54526d6dc16070390918cc5d0a0fd6f420fd8604a3a2b2c201caa7a821f893881aec2cbea991f696a9bdc1162079c77212aa868f18ced937d8e7ed7f2e79933d346e02806cce221ecbf2151d5555417d43add14f56709d61c387f0dd809de279275eb3c3acb8bd54f2a767f12630fd03f851ad92b812d6835406699fde6de695af9e67bfb5d69d86d20d1ad11de8b862aacb4c8431ae57524f1f63bdb92dd4fc1d1d639a4c3b27da59c060f9d3f6a4d41c3c9587d9677c7e6ac078aa1f7217c9a81fd6fd5fec1dccaa1c0cbc9712e409c6afdbe7becde9493339971b3b762d50afec52a4d0a1e462f53a3232e687fcf1cb2c34b4034002f5a099d7275dc642247584df998b5d3c22fc4d374100b0d383009e4a0dae749675d353116204244d5e0e6873f1c6bb61bcd3b7e985e89ff622202d9e4831663a8d0256196ad6e0ff026835f5e1f02de2c6ea72341c2e01fe20e639036c0ca9513b57814a768450f27227d0046023fda60cc046c058da8b9cb2398867417ee053f787b3289c69d44df0174be057a551ecd233a9221e38f6ba5a275f6a8f991ce13ad1f2c08ba9cee61a088727b38e0b1c3df9ce850c5ce196b1a18ac589d0036fd9c32d317cb601040bcc376dc43d21cc4550cb428a481f6c9459dd470382a6a47197925544685f55c4a0baf09739655a10e6532b5539ad04914f3f830a6d468fbfe51c1f56e90131bdf54b3b26882a94bd97d47a00a6695bb11b99885460215bef31d68dcf88d6c826436ee6c4e408e2cf4d31c112b9650e37dab84fde76f10209dd36f7994bc370f197523a5b0444e48f32834c7c15ad00fce298513f7797963db8b4ebf7c562942b502b3228df99624c531aa85407b1a3859c4e03988b4cf532c8ea61e46bec2383c4180fb493c0c8d7b6b2c2ed64bc24382b776cf2d998894d1c01672a93f74e3e662ba76655d775239aecee208018df0f26d9a642bf44b5dc2ef5ed78f62299c3231c42567d0b2160d068e23d5eef17b9facc5c59ca95e126823e068d841ab91293386ebb0f6ac4135f26c0f5dbaf51d381347f3a58c282510071348a5aeec1fd853dce6ac2b46379c4459bf2625b071356829cb16ec05b1730c36097aababc452582c09f37293573a93a337b6c24561fc0daae991af2b2364896da1b57e66d0fd38287dfac0c103ce471fee2fcc621f5ecac855795f78528f73bbc8642f47cedb1cca1cdf92046cd9a06a576de74a0dda16009d11bde3e87cdcead2d5f3631d133612228619332ab8a9429db25103c09f646946ab017ad6ec129324d9a3cd5166d3f708e0c42921bf352763c94773bf5e663e9fe428bac35f81f507572d295332e984894c406233e2bb95850d557094975a6669254b9722ac4267d23805498be4d7bc9e33e072821492a8c98b9bbdc914786b04d1a07d696389b570004be6c24f184f71effd57d498e6d7768ced29338e8dcbf1cf14f54846b86bdc77db91bb42dbf70d44677d48e3f0f93cad8b01604001a2e3825046fbcde35cfc74f664eafc20752e76c369b58f7ff7bb8c7f315fc3a4415892010d6d45dc5a8936cf0a586e2abe3b07d7142d9a19adcbff892ffd16a0871c3911c5ee9499156cceeb33707cd500f24830127c0423eda50f4c4943122b6471ec2a80b5d8511a1b372c94fcd347d804b2782894542710ff2d3b47600024285c5a6811acf52f075cb2c77c420bb8d2888e514d788c7c2760916137282419710845c54083e311702552d9c87a02ce01fb1870e71e38ba854d5a01fd06af53a4491a9d3f870f171eef049740adfa7da4813b6866a3017a56d104f36f9ac79d9ff1bb3884ab922d6927af014d11ba3fda3d9f293b2747cef869c6c907d398c0bce8ad450a2a0ec2c88ed04a18ad92140e7b462c0a57b49052201caba38976aa0902c7e0d1b6d73e8a074909b13ac2041f5d019469fec3ef21f9aa5c425811575ec8e16acafc5a0bcd1fa340a1a262f0707b08c4bd904e0872b44d242e67e838b8349801b62ac4a5e74d0d2b37685de7b2c7245890c826cf64fca7654cdb81ede95c0179e6421eace15bad23b829dfc4f688dd14786f7be74843750ece1036144cec39036de5c433b65cc0fd189835355bfc47c45adfefa0333f7ca8ce53f6799bd4d010b46e3ea34e2f3235d18339602be1142f798608559d1b9ff0c41154a69cda1690cb18675acd625d7a15eaaefa26e33e4e809c621eac1c7cb28454aaace0936b56a91c55f3f1a1781512f52a4016f813f8d295abc17727e4f039e509f7634e2f86acefad3cb3016e78b607b9ba870c70aa65964b554f285401570d5a02492a00519442fac7c004d2db2c18e8e77325c302ad4608f9d0ecb0e3f6e5d8bb5aa5c2129c4ee3ec148d1f3869672dcfe4aee27adad0e5e3120f99fa9d1a850c83c5ee7a2c36a5cf0bccc314fcc03a70bc3f9bc8dd12b9d9cde79a1705b4d5fcc81743c53379f36291b798472f24e137db74bd59fb7249f761936d3e1d50eb0296dc7e42331555222923fdebe510b478ef6c30c683c5f6d36d83eacda688cc50604daa81055b4e5f1efeebe16d89b402ae13f65955744e87aba7dce82e53c14e3cd17119d80f72fb6acb5233613ff06bfc62e7a73772e355816fe1d03683cfbea95ee61109e1aad67adffaa576b156ca394dd2021d863396a754c831eb8a3365feb11a5eb3701cbb048a38e6369008212e0ad808c0a957694a1fe500901836dd8ce49e427b852f1b9ed4c44a09e6366a46abb85f8e0c8c8d9671736efd4937c6cc5c31352c9e3277e9ccb926c5ffbeab39caa9294139072216df3f66419331197bfb7e289112bee9d056ed6a363df184ee752dca47e50fbe66807fb1835ae634ddcc5dd047b67174fd16fd36cd6f4f3244166615e496aad35559b3cb827c4c3294c7a67df547286a84912e59a164307463ff09633449d7e1c6c82f7e15aed2ed2235be5b3a8da6dd689dc02efc916d488e6057575dea649d1afdb5714c81bbe5224e19e0995588e7fc2076df0b6afd351bcebcb67847fb2cae082567004f98e399160f298b1a300d0b1fa72f9408d94bc0bad1e7a13b35f178b98d8bf37eb10152e4fbb25b83ff922ad07deb9dd9b432b92a887dcb142d99b123acbde457ecb5d6a5a5da23ee7168c945686868a11615764e230aca1739f88d3d59a7e9f3cf20c97cb7c5870bc48a9a3bfcf6da940dc5a0e4c5169b69bf555ba611851450b8c170a2cd13b7493060606647a84bf0d28b70dcc10ebcb266c43bd333629565b9043e632bee1080d3ce4873a67cb22ba350de2523a2027517c4a3350e1e2acface4b412eecd8ce106be195d41ad6640f9af2e787ed53a024eb3e8c4c4defd32e7c718a664ce4af699225c32bc73cd11bd305287c7c3e3a0f857404e62d45cc0e888f470f329ec1841f4348085e2db41e432c36722d3a07f8ed5bfb6a64103f90e68d70cb96e383bb12ce2457ee9fec1815e399701846582d18c814cb9391de5d0a62b32bb1061fdd2860b2bbe6b0ad7376af573a85a0c80f947a0e40fcf34b46e1d7a4f3ea68ed1bdef2574d92017f938cb3c9eb383d9cf4d6c13abb59a5412f989291435cda1019b879007bb68005ffc8a01f09b94af468aec1d1b546c1593f71517b4587e488f277a585d636472391c984431a4906ac01c5025cd3cc6218d6ae0828fcc9e25b3a385fa1d24f543f8a65eb733e86f413b9bb92e64e2101f424a735c9b1c120809302bd6ad9b8d6ea0ca6c1097cffd4f8529b2c99c0cf5e3e682889d4539bd8a29692adf2997721da8991b6b4cc32074c0f988f2234cd22aeac5c80bb36d3f2f56215e36ac6af41685fdf4d15259123f48042a63c2a08e115b2c82d7c6e2f6c5372692a565f8dd1d0076e127931e20288817b919146bb95ee82bb133cc9ffa13e31763afa7126a8df92659c3c914e4b461ece68a333dbee92b023db186948ffa8397b5718450d95da7b0eb5ae756e8e90ce977bec628ad0a7bd0171ba04294c83428f283ee4ef3459d50515976b87c365c1e70cde8b7c84bc1dfd54714d41d1894f4e59ede911cd3b96aa6a1f5db84a89c4bce27e3b9663ddbee713d2e53158c662e7bbb8c72649616f3e500ab67a013727b1c35039c57f93f12875cf9113be11390ef80d0879ba629ba94862e05fead378dafe30a17f37c87d749970715b15acc9f9675a4d6d78084caf0982a57b847de5d2309a5b82280ae2713449fc686f2959310a786f320d74ac8e22242dca315bb0acd79a9076f0373343013dfc005f8cf5254334c3ba2f82d7dc4bc61d7e098b0706c8d52e8cfa7f941417964b76e384d5aca1294b7e773fae7df8c3aeb05ba0655e7a6dc16b94084596038c50427dd6bb9d130b3a534726225f54677a6ac6a5607661df3f69939cb09b71f505175f8f1c6ced07e9fb4ffc2696215d98bc712e6dfe95e29e9d4debb6fa832c49c429a20db9c2b0b589905d3cbf9337a26781462ffc217eb289de7ecee9dec8e3b605fdace01d7ee948fc570965af16f7f838b800493f00431e593e438abcc877b45d3a5809ac1c0781d64dec2b607f5239a5cc578c9839c386dcc3e7af45457b585fd4b4bcf75f7b15033d6c613908e6a2dd69cc8d5de3a454b104385c26536397cb525d40dab10a563b099960909c43c2f798774396ee127caa0792d2f7b3959aad585872a5c370a4bc7f13666239208a611a119143f570bfd0b50cd3da71c7a686288cf416773a4f442acc9c56f43fad07383630790fbddca48d8238a56003f77de26d17603b0d38335b1c66b8cb353d525bde9e779dc9959c5cbb8507c49682fd7ad581f314685430c952fcb1ff428af3b117597c561b669e9b763d939bd95ff8563416acbf348bf6dff72d2bf4ca95c46a92821c5fbdb1a68d2098b57981317872e91433d2d07332fc7f3076541af2f01ed75560eae03720e35aed32ddc70678b81b08579bc022baf970e80488d0b78c1167d9a8a17e83b8ebae4e095543681d3bcf66add99015f997bef1c40636e763325bbd498b423069f28e9a9fdf67339e828ad3c9889224dbf18cebb2b5de9639ad3eb930f506afdc393c4a8b3c17fc99aa75f8be54726f7d24125fb5e345127eaeadd04cf1c0f8b4cb2a0b9aec4ba48d0a2b600f5af812e750eea625d2f502599581aae1a3ef688aa31fbf64e213aab9cf59eb7dc93e06045deaa5103ac459702d04967c479f6fc1ed6f70fb0d4fc230ae296262cc6cdb4c13f4cde805f26b242c3021bd49a02d982f56b073c0d55883d4102902b3241cec1d5f687de9af3d5c87b33b1105330711dfaaa624a3cf639b3154419c7ed556c9c50b8738528e281387d4639550c466f6fea60ae7bf272db4a26179a4f85ad69d7fe951dc2ee8bd7e7639b27860e2a3948b9f0b69d78d07eb5ad23ce5c6ade27dd0a896b5637975f78b16da8e9caa6b9cea3d66cb6458f922e6bc6c18d61256e1c9100793a3ce6928d8b49ccde17bb4c132ed6d72af3ef6f8a65454358110c4a46357f5ff8c07e6c4e99c070b7480122f18c84fbe1bf36b80be22d209251453727efe7ea57ae1d017484271e8a73f9f34c99f87f3159e57f7c54f109ac3dcc22db0d2931b482862cefccec960202c143118927f0ed48592f64c39351b256aaca27510771752094a84632c57b974f34cdb703cf562826cf892956d1521094557e56136bb5fd393946977dd892ba9aebba83d90b475ec3c1810bd94a75fb715ef3710ada56026cb44d6d10040dcc8bb6dc5247b87322be62c807733b76e6c3dcdaca7e7ca14fbba9d699f0b50718390bc99e62c38443ce5c07c385698ade26a61966ad9692692b2bce36489a7c899f4af6cc84118fc1359dd3705a6dbef602f1e6ab0d92440f2f3065073d69fc3f554d1b29964b8280cc208cfe1e858724e998ccb92c8435acfc01f99f6cd49352cf4c2518faef7fa0524c195fe64e018dd9d007f0612997d30e63108eed49b9762fd8ddd482feb82b09cdd2543050bd007d500d979803778410145684078d7f52896d29ea730c12a0063ad929fc4a4095396bfb07a6e5dadc82c8a5777852575bdf7c6ade28195f0955a6e8e14ed7ad8f67a31822bf02acf86f7abb56260a76504959901268342b5bb113b6c1b45f23f338b9d5e67303adf4006b80d2dc3ef65a01275c43103d866d99084da0630e0b9c46f6dd832a854b21d6fde60b72fa921a784a086c8460aedfdd03fcb486c13fb56dceb21e50575807ffd0a1289ba95cc3c199c266734b17670ee9906c86556f17d9f22e2d435bde15e608135fc1051406e8f750bfeb6355600056f6026760a965a02819813b8a7a40059f9312b5fcbbcd15fe52b0ed001219fdf282cfd8f4741a00cdffcd2ab8da75bbcefcc0afc4ece2cd355e29d5ac4fb533129e932dde57612abda2901fc22b32efc6411db1f1d4fd79bd46b2d8571dcf9434eeedb3a671806b880fac30d25a1d0267619782ef50e9405090051d9d06a1aa79afb1570dabc89a3466c0e3a1b365668adb5c313ecbd712f6ad748b965a6386f15c8c1dfa2b3afd454573e0c30c968491855fbff16db9fe049f24fe8dbd653d779b5d997b75b8b8b69792","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"d9a582ae721cedd50668d91803822905"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(passphrase, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
